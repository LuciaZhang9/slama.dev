---
title: Robotics 1
category: "notes"
category_icon: /assets/category-icons/heidelberg.webp
---

- .
{:toc}

{% lecture_notes_preface_heidelberg Lorenzo Masia|2022/2023%}

_Note that since the course hasn't ended yet, the notes are not complete and won't be until the end of the semester._

Lecture contents:

1. Introduction [[slides](/assets/robotics-1/slides/01_introduction.pdf)] [[tutorial -- basics](/assets/robotics-1/exercises/01.pdf)]
2. Robotics Components [[slides](/assets/robotics-1/slides/02_intro_to_robotic_components.pdf)] [[tutorial -- rotations, Gr端bler](/assets/robotics-1/exercises/02.pdf)]
3. Kinematics [[slides](/assets/robotics-1/slides/03_kinematics.pdf)] [[tutorial -- Gr端bler, DH](/assets/robotics-1/exercises/03.pdf)]
4. Homogeneous Transformation and DH [[slides](/assets/robotics-1/slides/04_homogeneous_transformation_and_dh.pdf)] [[tutorial -- DH](/assets/robotics-1/exercises/04.pdf)]
5. Inverse Kinematics [[slides](/assets/robotics-1/slides/05_inverse_kinematics.pdf)] [[tutorial -- DH, Inverse Kinematics](/assets/robotics-1/exercises/05.pdf)]
6. Inverse Kinematics (numerical methods) [[slides](/assets/robotics-1/slides/06_inverse_kinematics_numerical_methods.pdf)] [[tutorial -- Geometric Jacobian](/assets/robotics-1/exercises/06.pdf)]
7. Differential Kinematics [[slides](/assets/robotics-1/slides/07_differential_kinematics.pdf)]
8. Inverse Differential Kinematics [[slides](/assets/robotics-1/slides/08_inverse_differential_kinematics.pdf)] [[tutorial -- trajectory planning](/assets/robotics-1/exercises/08.pdf)]
9. Trajectory Planning in Joint Space [[slides](/assets/robotics-1/slides/09_trajectory_planning_in_joint_space.pdf)] [[tutorial -- inverse kinematics](/assets/robotics-1/exercises/09.pdf)]
10. Trajectory Planning in Cartesian Space [[slides](/assets/robotics-1/slides/10_trajectory_planning_in_cartesian_space.pdf)] [[tutorial -- Gr端bler, DH](/assets/robotics-1/exercises/10.pdf)]
11. Manipulability [[slides](/assets/robotics-1/slides/11_manipulability.pdf)] [[tutorial -- Jacobian, Lagrangian](/assets/robotics-1/exercises/11.pdf)]

### Robotics Components
{% math ENdefinition "link/member" %}individual bodies making up a mechanism{% endmath %}

{% math ENdefinition "joint" %}connection between multiple links{% endmath %}

{% math ENdefinition "kinematic pair" %}two links in contact such that it limits their relative{% endmath %}

- **low-order** kinematic pairs: point of contact is a surface (eg. revolute/prismatic/spherical)
- **high-order** kinematic pairs: point of contact is a dot/line (eg. gears)

{% math ENdefinition "kinematic chain" %}assembly of links connected by joints{% endmath %}
- is a **closed loop** (left image) if every link is connected to every other by at least two paths (including the ground -- imagine it as a single link), else it's **open** (right image)

![Open and closed kinematic chains](/assets/robotics-1/kinematic-chains.svg)

#### Degrees of Freedom

{% math ENdefinition: "deegree of freedom" %}of a mechanical system is the **number of independent parameters** that define its configuration. It can be calculated by the **Gr端bler Formula**:
{% endmath %}

\[\text{DOF} = \lambda (n - 1) - \sum_{i = 1}^{j} c_i\]

where 
- \(\lambda \ldots\)  DOF of the operating space (3 for 2D, 6 for 3D)
	- in 2D it's 2 for orientation and 1 for position
	- in 3D it's 3 for orientation and 3 for position
- \(n \ldots\) number of links
- \(j \ldots\) number of kinematic pairs
- \(c_j \ldots\) degree of constraint of the \(i\)-th kinematic pair
	- eg. a revolute joint in 2D takes away 2 DOF (we can only rotate)

For example, the following has \(3 (4 - 1) - 2 \cdot 4 = 1\) DOF:
![DOF](/assets/robotics-1/dof.svg)


{% math ENdefinition "coincident joints" %}when there are more than two kinematic pairs in the same joint{% endmath %}

![Coincident joints.](/assets/robotics-1/coincident-joints.svg)

#### Actuators
{% math ENdefinition "actuator" %}a mechanical device for moving or controlling something{% endmath %}

- **DC brushed motor**: based on Lorentz' force law (electromagnetic fields)
	- **brushed** because the metal brush powers the magnets (they're turning)
	- **brushless** uses the position of the motor to turn on/off currents for specific windings
	- usually contains **gears reductions** to trade torque for speed and **sensors** to measure the position of the motor (see further)

![DC motor illustration.](/assets/robotics-1/dc-motor.svg)

- since the voltage controls the motor but setting it to a specific value is impractical, **pulse width modulation (PWM)** is used:

![PWM](/assets/robotics-1/pwm.svg)

- to measure the position of the motor, **optical shaft encoders** (incremental/absolute) are used:

![Incremental and absolute optical encoders.](/assets/robotics-1/optical-encoders.svg)

### Kinematics
- establishment of various coordinate systems to represent the positions and orientations of rigid objects and with transformations among these coordinate systems

![Kinematic spaces.](/assets/robotics-1/kinematic-spaces.svg)

- the dimension of the **configuration space** (\(n\)) must be **larger or equal** to the dimension of the **task space** (\(m\)) to ensure the existence of kinematic solutions

#### Forward (direct) Kinematics

{% math ENdefinition "forward/direct kinematics" %}the process of finding the position/orientation of the **end-effector** \((r_1, \ldots, r_m)\) given a set of joint parameters \((q_1, \ldots, q_n)\).{% endmath %}

\[(r_1, \ldots, r_m) = F(q_1, \ldots, q_n)\]

##### Body Pose

The **pose/frame** of a rigid body can be described by its **position** and **orientation** (wrt. a reference frame).
- the **position** is a vector \(P \in \mathbb{R}^3\)
- the **rotation** is an **orthonormal matrix** \(R \in \mathbb{R}^{3 \times 3}\) with \(\det(R) = 1\) (a determinant of \(-1\) would flip the object, we only want rotation)
	- due to orthogonality: \(R^T = R^{-1}\)

\[R = \begin{bmatrix} x' & y' & z' \end{bmatrix} = \begin{bmatrix} x_x' & y_x' & z_x' \\ x_y' & y_y' & z_y' \\ x_z' & y_z' & z_z' \end{bmatrix}\]

The elementary rotations about each of the axes are the following:

<!---MARKDOWN-->

{:.rightFloatBox}
![Z rotation.](/assets/robotics-1/z-rotation.svg)

<!---PDF
-->

\[
\begin{aligned}
	R_x(\alpha) &= \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos \alpha & -\sin \alpha \\ 0 & \sin \alpha & \cos \alpha    \end{bmatrix} \\
	R_y(\alpha) &= \begin{bmatrix}  \cos \alpha & 0 & \sin \alpha  \\ 0 & 1 & 0 \\ -\sin \alpha & 0 & \cos \alpha  \end{bmatrix} \\
	R_z(\alpha) &= \begin{bmatrix}  \cos \alpha & -\sin \alpha & 0 \\ \sin \alpha & \cos \alpha & 0 \\ 0 & 0 & 1 \end{bmatrix} \\
\end{aligned}
\]

- important to remember for calculating robot kinematics (or just think about what the rotation about an axis is doing to the other two axes, it's not too hard to remember)
- positive values for the rotation are always **counter-clockwise** (just like normal rotations)

When discussing multiple frames, we use the following notation:

\[{\scriptstyle \text{to} \atop \scriptstyle\text{from}} R = {\scriptstyle \text{to} \atop \scriptstyle\text{}} R {\scriptstyle \text{} \atop \scriptstyle\text{from}} = R {\scriptstyle \text{to} \atop \scriptstyle\text{from}} \]

E.g. if we have the same point \(p_0, p_1, p_2\) in three different frames, we know that

\[
\begin{aligned}
p_1 &= R^1_2 \cdot p_2 \\
p_0 &= R^0_1 \cdot p_1 \\
p_0 &= R^0_2 \cdot p_2 = R^0_1 \left(R^1_2 \cdot p_2\right)
\end{aligned}
\]

For representing any rotation, we use **Euler's ZYZ angles**, which composes three rotations (Z, Y, Z):

\[
\begin{aligned}
	R &= R_z (\varphi) R_{y'} (\vartheta) R_{z''} (\psi) \\
	&= \begin{bmatrix} c_{\varphi} c_{\vartheta} c_{\psi} - s_{\varphi} s_{\psi} & -c_{\varphi} c_{\vartheta} s_{\psi} - s_{\varphi} c_{\psi} & c_{\varphi} s_{\vartheta} \\ s_{\varphi} c_{\vartheta} c_{\psi} + c_{\varphi} s_{\psi} & -s_{\varphi} c_{\vartheta} s_{\psi} + c_{\varphi} c_{\psi} & s_{\varphi} s_{\vartheta} \\ -s_{\vartheta} c_{\psi} & s_{\vartheta} s_{\psi} & c_{\vartheta} \end{bmatrix}
\end{aligned}
\]

For the inverse problem (calculating angles from a matrix of numbers), we can do
\[
\begin{aligned}
	\varphi &= \mathrm{atan}2 (r_{2,3}, r_{1, 3}) \\
	\vartheta &= \mathrm{atan}2 \left(\sqrt{r_{1,3}^2 + r_{2,3}^2}, r_{3, 3}\right) \quad \vartheta \in (0, \pi)\ \text{since we took + sign} \\
	\psi &= \mathrm{atan}2 \left(r_{3,2}, -r_{3,1}\right)
\end{aligned}
\]
- if we divide by zero somewhere we get degenerate solutions where we can only get the sum of the angles (one of the problems with Euler angles)
- alternative is **RPY angles**, which are also three rotations (roll, pitch, yaw) and are just as bad

##### Denavit & Hartenberg Notation
For relating the base and the end effector, we need to both **rotate** and **translate**, so we'll use **homogeneous coordinates** (matrix is \(4 \times 4\)), encoding both rotation and translation:

\[
{\scriptstyle \text{A} \atop \scriptstyle\text{EE}} A = \begin{bmatrix} {\scriptstyle \text{A} \atop \scriptstyle\text{EE}} R & {\scriptstyle \text{A} \atop \scriptstyle\text{EE}} P \\[0.7em] 0\ 0\ 0 & 1\end{bmatrix}
\]

To create the homogeneous coordinates in a standardized way, we use the Denavit & Hartenberg (DH) notation which systematically relates the frames of two consecutive links. We have **4 parameters**, each of which relates frame \(i\) to frame \(i - 1\):

| parameter                       | meaning                                                  |
| --:                             | ---                                                      |
| **link length \(a_i\)**         | distance between \(z_i\) and \(z_{i - 1}\) along \(x_i\) |
| **link offset \(d_i\)**         | distance between \(x_i\) and \(x_{i - 1}\) along \(z_i\) |
| **link twist \(\alpha_i\)**     | angle between \(z_i\) and \(z_{i - 1}\) around \(x_i\)   |
| **joint angle \(\vartheta_i\)** | angle between \(x_i\) and \(x_{i - 1}\) around \(z_i\)   |

![Denavit & Hartenberg Notation](/assets/robotics-1/dh.svg)

A mnemonic to remember which parameter relates which is that it's **from a to z** (i.e. \(a\) relates \(z\)s).

{:.rightFloatBox}
![Anthropomorphic arm.](/assets/robotics-1/anthropomorphic-arm.svg)

{% math ENexample %} anthropomorphic arm (3 revolute joins):{% endmath %}

|     | \(a_i\) | \(d_i\)     | \(\alpha_i\) | \(\vartheta_i\)   |
| --- | ---     | ---         | ---          | ---               |
| 1   | \(0\)   | \(0\)       | \(\pi / 2\)  | \(\vartheta_1^*\) |
| 2   | \(a_2\) | \(0\)       | \(0\)        | \(\vartheta_2^*\) |
| 3   | \(a_3\) | \(0\)       | \(0\)        | \(\vartheta_3^*\) |

We then get the following transformations:

\[
\begin{aligned}
	A^0_1 (\vartheta_1) &= \begin{bmatrix} c_1 & 0 & s_1 & 0 \\ s_1 & 0 & -c_1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \quad R = R_z(\vartheta_1) \cdot R_x(\pi / 2) \\
	A^{i-1}_i (\vartheta_1) &= \begin{bmatrix} c_i & -s_i & 0 & a_i c_i \\ s_i & c_i & 0 & a_i s_i \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \quad i = 2, 3\\
\end{aligned}
\]

To get the final transformations, we can multiply the matrices and get \[T^0_3 (\mathbf{q}) = A^0_1 A^1_2 A^2_3\]
This will yield the entire homogeneous matrix -- if we only want position, we can only focus on the last row, which simplifies the computation: \[p^0_3 (\mathbf{q}) = A^0_1 A^1_2 A^2_3 \cdot (0, 0, 0, 1)^T\]


Things to keep in mind:
- the \(Z\) axis is always the one we rotate about by \(\vartheta\)
- if the joint is prismatic, \(Z\) axis is instead the one that moves by \(d_i\)
- good idea to fill in the variables first and the rest after

#### Inverse Kinematics
{% math ENdefinition "inverse kinematics" %}the process of finding a set of joint parameters \((q_1, \ldots, q_n)\) given the position/orientation of the **end-effector** \((r_1, \ldots, r_m)\).{% endmath %}

\[(q_1, \ldots, q_n) = G(r_1, \ldots, r_m)\]

{% math ENdefinition "redundancy" %}arrises when there are _multiple inverse solutions_{% endmath %}

{% math ENdefinition "primary workspace" %}set \(\mathrm{WS}_1\) of all positions \(p\) that can be reached with _at least one_ orientation \(R\){% endmath %}

{% math ENdefinition "secondary workspace" %}set \(\mathrm{WS}_2\) of all positions \(p\) that can be reached with _all_ orientations \(R\){% endmath %}

![Workspaces example.](/assets/robotics-1/workspaces.png)


##### Analytical solution (closed form)
- preferred (if it can be found)
- use geometric inspection, solve system of equations

{:.rightFloatBox}
![Spherical wrist.](/assets/robotics-1/spherical-wrist.svg)

{% math ENexample %}spherical wrist (3 revolute joins):{% endmath %}

\[T_6^3(\mathbf{q}) = \begin{bmatrix} c_4 c_5 c_6 - s_4 s_6 & -c_4 c_5 s_6 - s_4 c_6 & c_4 s_5 & c_4 s_5 d_6 \\ s_4 c_5 c_6 + c_4 s_6 & -s_4 c_5 s_6 + c_4 c_6 & s_4 s_5 & s_4 s_5 d_6 \\ -s_5 c_6 & s_5 s_6 & c_5 & c_5 d_6 \\ 0 & 0 & 0 & 1 \end{bmatrix}
\]

The matrix \(R\) is a ZYZ Euler rotation matrix and can be solved as such (see [Body pose](#body-pose)).
- we use indexes \(3\) to \(6\), because the wrist is usually at an end of another manipulator

{% math ENdefinition "decoupling" %}dividing inverse kinematics problem for two simpler problems, **inverse position kinematics** and **inverse orientation kinematics**{% endmath %}
- is applicable for manipulators with _at least 6 joints_ where the _last 3 intersect at a point_
- the general approach is the following:
	1. calculate the orientations and position where the wrist needs to be
	2. calculate the orientations of the rest of the robot

##### Numerical solution (iterative form)
Two major ways of solving it, namely:

1. **Newton method:**
	- uses Taylor series around point \(q_k\) to expand the forward kinematics \[r = F(q) = F(q_k) + \underbrace{\frac{\partial F(q_k)}{\partial q}}_{\text{Jacobian}\ J(q_k)}(q - q_k) + \underbrace{\mathcal{O}(||q-q_k||^2)}_{\text{neglected}}\]
	- stripping the higher-order terms and solving for \(q\), we get \[\begin{aligned} r &= F(q_k) + J(q_k)(q - q_k) \\ r - F(q_k) &= J(q_k)(q - q_k) \\ J^{-1}(q_k)(r - F(q_k)) &= (q - q_k) \\ q = q_{k + 1} &= q_k + J^{-1}_r(q_k) \underbrace{(r - F(q_k)}_{\text{error}}) \end{aligned} \]
	- is nice when \(n = m\), otherwise we have to use the **pseudoinverse**
	- bad for problems near singularities (becomes unstable)



2. **Gradient method:**
	- aims to minimize the squared error \[H(q) = \frac{1}{2} ||r - F(q)|| = \frac{1}{2} [r - F(q)]^T [r - F(q)]\]
	- the gradient of \(\Delta_q H(q)\) is the steepest direction to minimize this error \[ \begin{aligned} \Delta_q H(q) &= \frac{1}{2} \cdot 2 \cdot (-1) \cdot [r - F(q)]^T J_r(q) \\ \nabla_q H(q) &= -J_r(q)^T [r - F(q)] \\ \end{aligned} \]
	- to move in this direction (given the current solution), we do \[\begin{aligned} q_{k + 1} = q_k - \alpha \Delta_q H(q_k) \\ q_{k + 1} = q_k + \alpha J_r(q)^T [r - F(q)] \end{aligned}\]
		- \(\alpha\) should be chosen appropriately (dictates the size of iteration steps)
	- we don't use the inverse but the transpose, which is nice!
	- may not converge but never diverges

They could also be combined -- gradient first (slow but steady), then Newton.


#### Velocity Kinematics
- relate linear/angular **velocities** of the end effector \(\dot{p}\) to those of the joints \(\dot{q}\)
- determined by the **Jacobian matrix** \(J\)
	- can be obtained either geometrically or by time differentiation
	- depends on the current configuration of the robot (encodes this information)
	- always a \(6 \times n\) matrix:
\[\begin{pmatrix} v_{EE} \\ \omega_{EE} \end{pmatrix} = \dot{p} = J(q)\dot{q} = \begin{pmatrix} J_L(q) \\ J_A(q) \end{pmatrix} \dot{q}\]

Here is a [nice video](https://www.youtube.com/watch?v=vjJgTvnQpBs) providing a high-level overview of the Jacobian matrix.

Two main cases when calculating the geometric Jacobian are the following:

|                            | **Prismatic Joint \(i\)**                                      |                                                                                                |
| \(J_{L_i} (q) \dot{q_i} \) | \(z_{i - 1} \dot{d_i}\)                                        | changes linear velocity (next joint moves linearly)                                            |
| \(J_{A_i} (q) \dot{q_i} \) | \(0\)                                                          | doesn't change the angular velocity                                                            |
|                            |                                                                |                                                                                                |
|                            | **Angular Joint \(i\)**                                        |                                                                                                |
| \(J_{L_i} (q) \dot{q_i} \) | \(\left(z_{i - 1} \times p_{i - 1, EE}\right) \dot{\theta_i}\) | changes linear velocity too -- moves next link<br>\(p\) is the vector from \(i - 1\) to \(EE\) |
| \(J_{A_i} (q) \dot{q_i} \) | \(z_{i - 1} \dot{\theta_i}\)                                   | changes angular velocity (next joint rotates linearly)                                         |

{:.rightFloatBox}
![Planar manipulator illustration.](/assets/robotics-1/planar-manipulator.svg)

{% math ENexample %}planar 2D arm:{% endmath %}

|     | \(a_i\) | \(d_i\) | \(\alpha_i\) | \(\vartheta_i\)         |
| --- | ---     | ---     | ---          | ---                     |
| 1   | \(a_1\) | \(0\)   | \(0\)        | \(\vartheta_1^* = q_1\) |
| 2   | \(a_2\) | \(0\)   | \(0\)        | \(\vartheta_2^* = q_2\) |

\[J = \begin{pmatrix} z_0 \times p_{0,EE} & z_1 \times p_{1, EE} \\ z_0 & z_1 \end{pmatrix}\]

To calculate \(z\)s and \(p\)s, it's best to calculate \(A\)s, which encode this information:

\[
\begin{aligned}
	z_{i - 1} &= R^0_1 (q_1) \cdot \ldots \cdot R^{i - 2}_{i - 1} (0, 0, 1)^T \\
	p_{i - 1, EE} &= p_{0,EE} (q_1, \ldots, q_n) - p_{0, i - 1}(q_1, \ldots, q_{i - 1})
\end{aligned}
\]

In our case:

\[A^0_1 = \begin{pmatrix} c_1 & -s_1 & 0 & a_1 c_1 \\ s_1 & c_1 & 0 & a_1 s_1 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \quad A^0_2 = \begin{pmatrix} c_{12} & -s_{12}& 0 & a_1 c_1 + a_2 c_{12} \\ s_{12} & c_{12} & 0 & a_1 s_1 + a_2 s_{12} \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}\]

We get \[p_{0,1} = (a_1 c_1, a_1 s_1, 0)^T \qquad p_{0, EE} = (a_1 c_1 + a_2 c_{12}, a_1 s_1 + a_2 s_{12}, 0)^T\]

Since \(p_{1,EE} = p_{0,EE} - p_{0,1}\), we get the \(p\)s and, as we see, \(z_0 = z_1 = z_2 = (0, 0, 1)^T\)

The full Jacobian matrix looks like this:
\[J = \begin{pmatrix} z_0 \times p_{0,EE} & z_1 \times p_{1, EE} \\ z_0 & z_1 \end{pmatrix} = \begin{pmatrix} -a_1 s_1 - a_2 s_{12} & -a_2 s_{12} \\ a_1 c_1 + a_2 c_{12} & a_2 c_{12} \\ 0 & 0 \\ 0 & 0 \\ 0 & 0 \\ 1 & 1\end{pmatrix}\]

The rank of the matrix is between \(1\) and \(2\), depending on the joint configuration.

##### Higher-orders
For calculating other differential relations, we can just continue to derivate:

| Relation     | Equation                                                                                             |
| ---          | ---                                                                                                  |
| velocity     | \(\dot{r} = J_r(q) \dot{q}\)                                                                         |
| acceleration | \(\ddot{r} = J_r(q) \ddot{q} + \dot{J_r}(q) \dot{q}\)                                                |
| jerk         | \(\overset{\ldots}{r} = J_r(q) \overset{\ldots}{q} + \dot{J_r}(q) \ddot{q} + \ddot{J_r}(q) \dot{q}\) |
| snap         | etc.                                                                                                 |

#### Force Kinematics
We can again use the Jacobian to relate **forces** of the end effector to those of the joints

Given \(\tau \in \mathbb{R}^{n \times 1}\) as the vector of infinitesimal joint torques and \(\gamma \in \mathbb{R}^{m \times 1}\) as the vector of infinitesimal end effector forces and torques. Applying the principle of virtual work (\(dW = dF dx = 0\)), we get
\[\tau = J^T(q) \gamma\]

This creates **kinetostatic duality** of the Jacobian

{: .no-invert}
![Kinetostatic Duality illustration.](/assets/robotics-1/duality.png)

#### Inverse Velocity Kinematics
- inverse problem to velocity kinematics
- for square non-singular \(J\), we can just do \(\dot{q} = J^{-1} (q) v\)
- has problems:
	- \(\dot{q}\) is large near singularities
	- for redundant robots, we don't have an inverse

##### Singularities

In configurations where the Jacobian loses rank, we're in a **kinematic singularity** -- we cannot find a joint velocity that realizes the desired end-effector velocity in an arbitrary direction of the task space.
- for example, when a planar arm is stretched or folded
- close to the singularity, the joint velocities might be very large
	- to remedy this, certain methods exist that balance error and velocity to make the robot movement smoother, like **camped least squares**

##### Pseudo-inverse
In the case that the Jacobian doesn't have an inverse (we can't satisfy \(H \dot{q} = v\), either because of singularities or redundancy), we want to find \(H\) that minimizes \[|| H \dot{q} - v ||\]

- the pseudo-inverse \(J^\#\) is the one we're looking for
- can be generally obtained using SVD
- also satisfies the following conditions:
	- \(J J^\# J = J\)
	- \(J^\# J J^\# = J^\#\)
	- \((J^\# J)^T = J^\# J\)
	- \((J J^\#)^T = J J^\#\)
	- for \(m < n:\) \(J^\# = J^T (J J^T)^{-1}\)

### Trajectory Planning

#### In Joint Space
**Goal:** generate reference inputs to the controller when given:
1. only start and end defined (minimum requirements)
2. sequence of points defined (more difficult)

{% math ENdefinition "path" %}locus of points in the joint space which the manipulator has to follow in the execution of the assigned motion (purely geometric).{% endmath %}

{% math ENdefinition "trajectory" %}a path on which a timing is specified (velocities, accelerations, etc.).{% endmath %}
- i.e. **trajectory = geometric path + time law**

To plan the path, we do the following:
1. get the sequence of pose points (i.e. **knots**) in the Cartesian space
2. create a geometric path linking the knots (interpolation)
3. sample the path and transform the sequence to the Joint space
4. interpolate in the Joint space

{: .no-invert}
![Trajectory Planning example.](/assets/robotics-1/tp.png)

We do this because planning in the Cartesian space can easily move the robot into configurations that can't be realized, which isn't the case for the Joint space.

The **time law** is chosen based on task specification:
- stop at a point, move at constant velocity
- considers constraints and capabilities (max velocity, accelerations)
- may attempt to optimize some metric (min transfer time, min energy, etc.)

##### Cubic polynomial
Useful for interpolating between two positions (\(q_0, q_1\)) given the start and end velocity (\(v_0, v_1\)).
- gives conditions \(q(0) = q_0, q(1) = q_1, q'(0) = v_0, q'(1) = v_1\)

The cubic polynomial is in the normalized form \[q(\lambda) = q_0 + \Delta q[a \lambda^3 + b \lambda^2 + c \lambda + d] \qquad \text{for}\ \Delta q = q_1 - q_0; \lambda \in \left[0, 1\right]\]

Plugging for known values helps us solve the polynomial:
- \(q(0) = q_0 \Rightarrow d = 0\)
- \(q'(0) = \Delta q \cdot c \Rightarrow c = v_0 / \Delta q\)
- \(q(1) = q_1 \Rightarrow a + b + c = 1\)
- \(q'(1) = \Delta q \cdot (3a + 2b + c) \Rightarrow 3a + 2b + c = v_1 / \Delta q\)

##### Splines
When we have \(N\) knots and want continuity up to the second derivative, we can **concatenate \(N - 1\) cubic polynomials**, which _minimizes the curvature among all interpolating functions_ (with 2nd derivatives)
- \(4(N - 1)\) coefficients
- \(4(N - 1) - 2\) conditions:
	- \(2(N - 1)\) for the positions of the knots
	- \(2(N - 2)\) for the continuity for first and second derivative at the internal knots
- we have \(2\) free parameters for assigning \(v_1, v_N\)

### TODO: presentation 10

### TODO: presentation 11

{: .no-invert}
![Cubic spline illustration](/assets/robotics-1/spline.png)
